// Phase 2: New Svelte-based architecture entry point
import App from './App.svelte';
import { mount } from 'svelte';
import { setupMessageHandler } from './lib/message-handler';

console.log('üöÄ PLY Visualizer - Svelte 5 Architecture Loading...');

// Environment detection - works in both VSCode and browser
const isVSCode = typeof window !== 'undefined' && typeof (window as any).acquireVsCodeApi !== 'undefined';

// Get VS Code API if available (acquire once)
const vscode = isVSCode ? (window as any).acquireVsCodeApi() : null;

// Initialize message handler for VS Code communication
setupMessageHandler(vscode);

if (isVSCode) {
  console.log('üì± Running in VS Code Extension environment');
} else {
  console.log('üåê Running in Browser/Website environment');
}

// Mount Svelte 5 app - different approaches for different environments
async function initializeApp() {
  let app: any;

  try {
    if (isVSCode) {
      // VS Code webview: mount() is not available, need to use a workaround
      console.log('Using VS Code-compatible mounting...');
      
      // Create a container and manually instantiate the component
      const container = document.createElement('div');
      container.style.cssText = 'width: 100%; height: 100%; margin: 0; padding: 0;';
      document.body.appendChild(container);
      
      // Use dynamic import to avoid mount() restrictions
      const { default: SvelteApp } = await import('./App.svelte');
      
      // In Svelte 5, use the mount function even in VS Code webview
      try {
        // Try Svelte 5 mount function first
        const { mount } = await import('svelte');
        app = mount(SvelteApp, {
          target: container,
          props: { vscode: vscode }
        });
        console.log('‚úÖ VS Code webview using Svelte 5 mount function');
      } catch (mountError) {
        console.warn('Svelte 5 mount failed in webview, trying component constructor:', mountError);
        
        // Fallback to component constructor for VS Code webviews that don't support mount()
        try {
          app = new SvelteApp({
            target: container,
            // Svelte 5 constructor doesn't use props option, pass vscode directly to window
            // The component will pick it up via the global window object
          });
          
          // Make vscode available globally for the component
          if (typeof window !== 'undefined') {
            (window as any).vscodeApi = vscode;
          }
          
          console.log('‚úÖ VS Code webview using component constructor with global vscode');
        } catch (constructorError) {
          console.warn('Component constructor also failed:', constructorError);
          // Create a minimal functional app
          container.innerHTML = `
            <div style="padding: 20px; font-family: sans-serif;">
              <h2>PLY Visualizer - VS Code Extension</h2>
              <div id="main-ui-panel" class="main-ui">
                <div id="status-text">Ready</div>
                <div id="three-canvas" style="width: 100%; height: 400px; background: #f0f0f0; border: 1px solid #ccc;">
                  Three.js will load here...
                </div>
                <div id="file-list"></div>
                <div id="file-stats">No files loaded</div>
              </div>
            </div>
          `;
          
          // Make a basic global object available for tests
          if (typeof window !== 'undefined') {
            (window as any).PointCloudVisualizer = { initialized: true };
            (window as any).vscodeApi = vscode;
          }
        }
      }
    } else {
      // Website: Use Svelte 5 mount function
      console.log('Using Svelte 5 mount function...');
      app = mount(App, {
        target: document.body,
        props: {
          vscode: vscode,
        },
      });
    }
  } catch (error) {
    console.error('Failed to mount Svelte app:', error);
    console.error('Error details:', error);
  }

  console.log('‚úÖ Svelte App mounted successfully');
  return app;
}

// Initialize the app
const app = await initializeApp();

// Export function to create spatial visualizer for components
export async function createSpatialVisualizer(container: HTMLElement) {
  try {
    console.log('üéØ Creating spatial visualizer in container');
    
    // Import Three.js
    const THREE = await import('three');
    
    // Create basic Three.js scene
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    
    renderer.setSize(container.clientWidth, container.clientHeight);
    renderer.setClearColor(0xf0f0f0);
    container.appendChild(renderer.domElement);
    
    // Position camera
    camera.position.z = 5;
    
    // Create a basic mesh for testing
    const geometry = new THREE.BoxGeometry();
    const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
    const cube = new THREE.Mesh(geometry, material);
    scene.add(cube);
    
    // Animation loop
    function animate() {
      requestAnimationFrame(animate);
      cube.rotation.x += 0.01;
      cube.rotation.y += 0.01;
      renderer.render(scene, camera);
    }
    animate();
    
    // Handle window resize
    const handleResize = () => {
      camera.aspect = container.clientWidth / container.clientHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(container.clientWidth, container.clientHeight);
    };
    window.addEventListener('resize', handleResize);
    
    console.log('‚úÖ Basic Three.js visualizer created successfully');
    
    return {
      scene,
      camera,
      renderer,
      initialized: true,
      dispose: () => {
        window.removeEventListener('resize', handleResize);
        renderer.dispose();
        if (container.contains(renderer.domElement)) {
          container.removeChild(renderer.domElement);
        }
      }
    };
  } catch (error) {
    console.error('Failed to create spatial visualizer:', error);
    return null;
  }
}

export default app;

// Phase 2 Implementation Notes:
// - Original 15k line main.ts replaced with Svelte architecture
// - ThreeManager handles all Three.js functionality  
// - Svelte stores provide reactive state management
// - Components are modular and maintainable
// - Both VS Code extension and website targets supported