import { describe, it, expect } from 'vitest';
import { parsePointCloudBinaryData } from '../website/src/utils/binaryDataParser';

describe('Point Cloud Integration Test', () => {
  it('should handle the exact message format from console output', () => {
    // This test replicates the exact data from your console:
    // vertexCount: 1250, vertexStride: 51, hasColors: true, hasNormals: true
    const vertexCount = 5; // Use smaller number for test performance
    const stride = 51;
    const totalSize = vertexCount * stride;

    const buffer = new ArrayBuffer(totalSize);
    const view = new DataView(buffer);

    // Create realistic test data matching the PLY structure
    const testVertices = [
      { pos: [0.1, 0.2, 0.3], normal: [0.0, 0.0, 1.0], color: [128, 64, 192] },
      { pos: [1.1, 1.2, 1.3], normal: [0.0, 1.0, 0.0], color: [255, 128, 64] },
      { pos: [2.1, 2.2, 2.3], normal: [1.0, 0.0, 0.0], color: [64, 255, 128] },
      { pos: [3.1, 3.2, 3.3], normal: [0.707, 0.707, 0.0], color: [200, 100, 50] },
      { pos: [4.1, 4.2, 4.3], normal: [0.0, 0.707, 0.707], color: [75, 175, 225] },
    ];

    for (let i = 0; i < vertexCount; i++) {
      const offset = i * stride;
      const vertex = testVertices[i];

      // Position (floats at offset 0, 4, 8)
      view.setFloat32(offset + 0, vertex.pos[0], true);
      view.setFloat32(offset + 4, vertex.pos[1], true);
      view.setFloat32(offset + 8, vertex.pos[2], true);

      // Normal (floats at offset 12, 16, 20)
      view.setFloat32(offset + 12, vertex.normal[0], true);
      view.setFloat32(offset + 16, vertex.normal[1], true);
      view.setFloat32(offset + 20, vertex.normal[2], true);

      // Color (uint8 at offset 24, 25, 26)
      view.setUint8(offset + 24, vertex.color[0]);
      view.setUint8(offset + 25, vertex.color[1]);
      view.setUint8(offset + 26, vertex.color[2]);
    }

    // Create message matching your console output format
    const message = {
      type: 'ultimateRawBinaryData',
      messageType: 'multiSpatialData',
      fileName: 'sample_pointcloud.ply',
      vertexCount,
      faceCount: 0,
      hasColors: true,
      hasNormals: true,
      format: 'binary_little_endian',
      comments: ['Generated by test'],
      rawBinaryData: buffer, // This is the key - rawBinaryData not binaryData
      vertexStride: stride,
      propertyOffsets: [
        'x',
        { offset: 0, type: 'float' },
        'y',
        { offset: 4, type: 'float' },
        'z',
        { offset: 8, type: 'float' },
        'nx',
        { offset: 12, type: 'float' },
        'ny',
        { offset: 16, type: 'float' },
        'nz',
        { offset: 20, type: 'float' },
        'red',
        { offset: 24, type: 'uchar' },
        'green',
        { offset: 25, type: 'uchar' },
        'blue',
        { offset: 26, type: 'uchar' },
      ],
      littleEndian: true,
    };

    // This should work without throwing
    const result = parsePointCloudBinaryData(message);

    // Verify structure
    expect(result.vertexCount).toBe(vertexCount);
    expect(result.positions).toHaveLength(vertexCount * 3);
    expect(result.colors).toHaveLength(vertexCount * 3);
    expect(result.normals).toHaveLength(vertexCount * 3);

    // Verify first vertex data
    expect(result.positions[0]).toBeCloseTo(0.1, 5);
    expect(result.positions[1]).toBeCloseTo(0.2, 5);
    expect(result.positions[2]).toBeCloseTo(0.3, 5);

    expect(result.normals![0]).toBeCloseTo(0.0, 5);
    expect(result.normals![1]).toBeCloseTo(0.0, 5);
    expect(result.normals![2]).toBeCloseTo(1.0, 5);

    expect(result.colors![0]).toBeCloseTo(128 / 255, 5);
    expect(result.colors![1]).toBeCloseTo(64 / 255, 5);
    expect(result.colors![2]).toBeCloseTo(192 / 255, 5);

    // Verify last vertex data
    const lastIndex = (vertexCount - 1) * 3;
    expect(result.positions[lastIndex]).toBeCloseTo(4.1, 5);
    expect(result.positions[lastIndex + 1]).toBeCloseTo(4.2, 5);
    expect(result.positions[lastIndex + 2]).toBeCloseTo(4.3, 5);

    console.log('✅ Integration test passed - binary data parsing works correctly!');
  });

  it('should work with 1250 vertices like in actual message', () => {
    // Test with the actual vertex count from your console
    const vertexCount = 1250;
    const stride = 51;
    const totalSize = vertexCount * stride;

    const buffer = new ArrayBuffer(totalSize);
    const view = new DataView(buffer);

    // Fill with test data
    for (let i = 0; i < vertexCount; i++) {
      const offset = i * stride;

      // Position
      view.setFloat32(offset + 0, i * 0.1, true);
      view.setFloat32(offset + 4, i * 0.2, true);
      view.setFloat32(offset + 8, i * 0.3, true);

      // Normal
      view.setFloat32(offset + 12, 0.0, true);
      view.setFloat32(offset + 16, 0.0, true);
      view.setFloat32(offset + 20, 1.0, true);

      // Color
      view.setUint8(offset + 24, (i * 17) % 256);
      view.setUint8(offset + 25, (i * 37) % 256);
      view.setUint8(offset + 26, (i * 73) % 256);
    }

    const message = {
      type: 'ultimateRawBinaryData',
      messageType: 'multiSpatialData',
      fileName: 'sample_pointcloud.ply',
      vertexCount,
      faceCount: 0,
      hasColors: true,
      hasNormals: true,
      format: 'binary_little_endian',
      comments: ['Test with actual vertex count'],
      rawBinaryData: buffer,
      vertexStride: stride,
      propertyOffsets: [
        'x',
        { offset: 0, type: 'float' },
        'y',
        { offset: 4, type: 'float' },
        'z',
        { offset: 8, type: 'float' },
        'nx',
        { offset: 12, type: 'float' },
        'ny',
        { offset: 16, type: 'float' },
        'nz',
        { offset: 20, type: 'float' },
        'red',
        { offset: 24, type: 'uchar' },
        'green',
        { offset: 25, type: 'uchar' },
        'blue',
        { offset: 26, type: 'uchar' },
      ],
      littleEndian: true,
    };

    const start = performance.now();
    const result = parsePointCloudBinaryData(message);
    const end = performance.now();

    expect(result.vertexCount).toBe(1250);
    expect(result.positions).toHaveLength(1250 * 3);
    expect(result.colors).toHaveLength(1250 * 3);
    expect(result.normals).toHaveLength(1250 * 3);

    console.log(`✅ Parsed 1250 vertices in ${(end - start).toFixed(2)}ms`);
  });
});
